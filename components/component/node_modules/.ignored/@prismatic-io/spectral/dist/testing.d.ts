/**
 * This module provides functions to help developers unit
 * test custom components prior to publishing them. For
 * information on unit testing, check out our docs:
 * https://prismatic.io/docs/custom-components/writing-custom-components/#testing-a-component
 */
import { TriggerPayload, TriggerResult, ConnectionValue, ActionLogger, Component, ActionContext, ActionPerformReturn, DataSourceResult, DataSourceContext } from "./serverTypes";
import { ConnectionDefinition, ActionDefinition, TriggerDefinition, Inputs, ActionInputParameters, DataSourceDefinition, ActionPerformReturn as InvokeActionPerformReturn, TriggerResult as InvokeTriggerResult, DataSourceResult as InvokeDataSourceResult, TriggerEventFunctionReturn, Flow, ConfigVarResultCollection, ConfigPages, ComponentSelector } from "./types";
export declare const createConnection: <T extends ConnectionDefinition>({ key }: T, values: Record<string, unknown>, tokenValues?: Record<string, unknown> | undefined) => ConnectionValue;
export declare const defaultConnectionValueEnvironmentVariable = "PRISMATIC_CONNECTION_VALUE";
export declare const connectionValue: (envVarKey?: string) => ConnectionValue;
/**
 * Pre-built mock of ActionLogger. Suitable for asserting logs are created as expected.
 * See https://prismatic.io/docs/custom-components/writing-custom-components/#verifying-correct-logging-in-action-tests for information on testing correct logging behavior in your custom component.
 */
export declare const loggerMock: () => ActionLogger;
/**
 * The type of data returned by an `invoke()` function used for unit testing component actions and triggers.
 */
interface InvokeReturn<ReturnData> {
    result: ReturnData;
    loggerMock: ActionLogger;
}
/**
 * Invokes specified ActionDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching ActionPerformReturn as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * action result and a mock logger for asserting logging.
 */
export declare const invoke: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TReturn extends InvokeActionPerformReturn<TAllowsBranching, unknown>>({ perform, }: ActionDefinition<TInputs, TConfigVars, TAllowsBranching, TReturn>, params: ActionInputParameters<TInputs>, context?: Partial<ActionContext<TConfigVars>> | undefined) => Promise<InvokeReturn<TReturn>>;
export declare const defaultTriggerPayload: () => TriggerPayload;
/**
 * Invokes specified TriggerDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching TriggerResult as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * trigger result and a mock logger for asserting logging.
 */
export declare const invokeTrigger: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TResult extends InvokeTriggerResult<TAllowsBranching, TriggerPayload>>({ perform, }: TriggerDefinition<TInputs, TConfigVars, TAllowsBranching, TResult>, context?: Partial<ActionContext<TConfigVars>> | undefined, payload?: TriggerPayload | undefined, params?: ActionInputParameters<TInputs> | undefined) => Promise<InvokeReturn<TResult>>;
/**
 * Invokes specified DataSourceDefinition perform function using supplied params.
 * Accepts a generic type matching DataSourceResult as a convenience to avoid extra
 * casting within test methods. Returns a DataSourceResult.
 */
export declare const invokeDataSource: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TDataSourceType extends keyof {
    string: string;
    date: string;
    timestamp: string;
    picklist: string[] | import("./types").Element[];
    schedule: {
        value: string;
    };
    code: string;
    boolean: boolean;
    number: number;
    objectSelection: import("./types").ObjectSelection;
    objectFieldMap: import("./types").ObjectFieldMap;
    jsonForm: import("./types").JSONForm;
}>({ perform }: DataSourceDefinition<TInputs, TConfigVars, TDataSourceType>, params: ActionInputParameters<TInputs>, context?: Partial<DataSourceContext<TConfigVars>> | undefined) => Promise<InvokeDataSourceResult<TDataSourceType>>;
declare type TestConnectionValue = Pick<ConnectionValue, "fields" | "context" | "token">;
declare type TestConfigVarValues = Record<string, string | TestConnectionValue>;
declare type ToTestValues<TConfigVars extends ConfigVarResultCollection> = {
    [K in keyof TConfigVars]: TConfigVars[K] extends ConnectionDefinition ? TestConnectionValue : string;
};
/**
 * Invokes specified Flow of a Code Native Integration using supplied params.
 * Runs the Trigger and then the Action function and returns the result of the Action.
 */
export declare const invokeFlow: <TConfigPages extends ConfigPages<any>, TConfigVars extends ConfigVarResultCollection = import("./types/utils").Prettify<{ [Key in keyof import("./types").GetElements<TConfigPages> as Key extends string ? Key : never]: import("./types").ElementToRuntimeType<import("./types").GetElements<TConfigPages>[Key]>; }>, TConfigVarValues extends TestConfigVarValues = ToTestValues<TConfigVars>>(flow: Flow<TConfigPages, ComponentSelector<any>, import("./types").TriggerPayload>, { configVars, context, payload, }?: {
    configVars?: TConfigVarValues | undefined;
    context?: Partial<ActionContext<TConfigVars>> | undefined;
    payload?: Partial<TriggerPayload> | undefined;
}) => Promise<InvokeReturn<InvokeActionPerformReturn<false, unknown>>>;
export declare class ComponentTestHarness<TComponent extends Component> {
    component: TComponent;
    constructor(component: TComponent);
    private buildParams;
    connectionValue({ key }: ConnectionDefinition): ConnectionValue;
    trigger<TConfigVars extends ConfigVarResultCollection>(key: string, payload?: TriggerPayload, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerResult>;
    triggerOnInstanceDeploy<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<void | TriggerEventFunctionReturn>;
    triggerOnInstanceDelete<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<void | TriggerEventFunctionReturn>;
    action<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<ActionPerformReturn>;
    dataSource<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<DataSourceContext<TConfigVars>>): Promise<DataSourceResult>;
}
export declare const createHarness: <TComponent extends Component>(component: TComponent) => ComponentTestHarness<TComponent>;
declare const _default: {
    loggerMock: () => ActionLogger;
    invoke: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TReturn extends InvokeActionPerformReturn<TAllowsBranching, unknown>>({ perform, }: ActionDefinition<TInputs, TConfigVars, TAllowsBranching, TReturn>, params: ActionInputParameters<TInputs>, context?: Partial<ActionContext<TConfigVars>> | undefined) => Promise<InvokeReturn<TReturn>>;
    invokeTrigger: <TInputs_1 extends Inputs, TConfigVars_1 extends ConfigVarResultCollection, TAllowsBranching_1 extends boolean, TResult extends InvokeTriggerResult<TAllowsBranching_1, TriggerPayload>>({ perform, }: TriggerDefinition<TInputs_1, TConfigVars_1, TAllowsBranching_1, TResult>, context?: Partial<ActionContext<TConfigVars_1>> | undefined, payload?: TriggerPayload | undefined, params?: ActionInputParameters<TInputs_1> | undefined) => Promise<InvokeReturn<TResult>>;
    createHarness: <TComponent extends Component>(component: TComponent) => ComponentTestHarness<TComponent>;
    invokeDataSource: <TInputs_2 extends Inputs, TConfigVars_2 extends ConfigVarResultCollection, TDataSourceType extends keyof {
        string: string;
        date: string;
        timestamp: string;
        picklist: string[] | import("./types").Element[];
        schedule: {
            value: string;
        };
        code: string;
        boolean: boolean;
        number: number;
        objectSelection: import("./types").ObjectSelection;
        objectFieldMap: import("./types").ObjectFieldMap;
        jsonForm: import("./types").JSONForm;
    }>({ perform }: DataSourceDefinition<TInputs_2, TConfigVars_2, TDataSourceType>, params: ActionInputParameters<TInputs_2>, context?: Partial<DataSourceContext<TConfigVars_2>> | undefined) => Promise<InvokeDataSourceResult<TDataSourceType>>;
};
export default _default;
