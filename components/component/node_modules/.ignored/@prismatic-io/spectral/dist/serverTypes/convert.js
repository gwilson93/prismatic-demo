"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertComponent = exports.convertInput = void 0;
const types_1 = require("../types");
const perform_1 = require("./perform");
const lodash_1 = require("lodash");
const convertInput = (key, _a) => {
    var { default: defaultValue, type, label, collection } = _a, rest = __rest(_a, ["default", "type", "label", "collection"]);
    const keyLabel = collection === "keyvaluelist" && typeof label === "object"
        ? label.key
        : undefined;
    return Object.assign(Object.assign({}, (0, lodash_1.omit)(rest, ["onPremControlled"])), { key,
        type, default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : types_1.InputFieldDefaultMap[type], collection, label: typeof label === "string" ? label : label.value, keyLabel, onPremiseControlled: ("onPremControlled" in rest && rest.onPremControlled) || undefined });
};
exports.convertInput = convertInput;
const convertAction = (actionKey, _a, hooks) => {
    var { inputs = {}, perform } = _a, action = __rest(_a, ["inputs", "perform"]);
    const convertedInputs = Object.entries(inputs).map(([key, value]) => (0, exports.convertInput)(key, value));
    const inputCleaners = Object.entries(inputs).reduce((result, [key, { clean }]) => (Object.assign(Object.assign({}, result), { [key]: clean })), {});
    return Object.assign(Object.assign({}, action), { key: actionKey, inputs: convertedInputs, perform: (0, perform_1.createPerform)(perform, {
            inputCleaners,
            errorHandler: hooks === null || hooks === void 0 ? void 0 : hooks.error,
        }) });
};
const convertTrigger = (triggerKey, _a, hooks) => {
    var { inputs = {}, perform, onInstanceDeploy, onInstanceDelete } = _a, trigger = __rest(_a, ["inputs", "perform", "onInstanceDeploy", "onInstanceDelete"]);
    const convertedInputs = Object.entries(inputs).map(([key, value]) => (0, exports.convertInput)(key, value));
    const inputCleaners = Object.entries(inputs).reduce((result, [key, { clean }]) => (Object.assign(Object.assign({}, result), { [key]: clean })), {});
    const result = Object.assign(Object.assign({}, trigger), { key: triggerKey, inputs: convertedInputs, perform: (0, perform_1.createPerform)(perform, {
            inputCleaners,
            errorHandler: hooks === null || hooks === void 0 ? void 0 : hooks.error,
        }) });
    if (onInstanceDeploy) {
        result.onInstanceDeploy = (0, perform_1.createPerform)(onInstanceDeploy, {
            inputCleaners,
            errorHandler: hooks === null || hooks === void 0 ? void 0 : hooks.error,
        });
        result.hasOnInstanceDeploy = true;
    }
    if (onInstanceDelete) {
        result.onInstanceDelete = (0, perform_1.createPerform)(onInstanceDelete, {
            inputCleaners,
            errorHandler: hooks === null || hooks === void 0 ? void 0 : hooks.error,
        });
        result.hasOnInstanceDelete = true;
    }
    return result;
};
const convertDataSource = (dataSourceKey, _a, hooks) => {
    var { inputs = {}, perform } = _a, dataSource = __rest(_a, ["inputs", "perform"]);
    const convertedInputs = Object.entries(inputs).map(([key, value]) => (0, exports.convertInput)(key, value));
    const inputCleaners = Object.entries(inputs).reduce((result, [key, { clean }]) => (Object.assign(Object.assign({}, result), { [key]: clean })), {});
    return Object.assign(Object.assign({}, dataSource), { key: dataSourceKey, inputs: convertedInputs, perform: (0, perform_1.createPerform)(perform, {
            inputCleaners,
            errorHandler: hooks === null || hooks === void 0 ? void 0 : hooks.error,
        }) });
};
const convertConnection = (_a) => {
    var { inputs = {} } = _a, connection = __rest(_a, ["inputs"]);
    const convertedInputs = Object.entries(inputs).map(([key, value]) => (0, exports.convertInput)(key, value));
    return Object.assign(Object.assign({}, connection), { inputs: convertedInputs });
};
const convertComponent = (_a) => {
    var { connections = [], actions = {}, triggers = {}, dataSources = {}, hooks } = _a, definition = __rest(_a, ["connections", "actions", "triggers", "dataSources", "hooks"]);
    const convertedActions = Object.entries(actions).reduce((result, [actionKey, action]) => (Object.assign(Object.assign({}, result), { [actionKey]: convertAction(actionKey, action, hooks) })), {});
    const convertedTriggers = Object.entries(triggers).reduce((result, [triggerKey, trigger]) => (Object.assign(Object.assign({}, result), { [triggerKey]: convertTrigger(triggerKey, trigger, hooks) })), {});
    const convertedDataSources = Object.entries(dataSources).reduce((result, [dataSourceKey, dataSource]) => (Object.assign(Object.assign({}, result), { [dataSourceKey]: convertDataSource(dataSourceKey, dataSource, hooks) })), {});
    return Object.assign(Object.assign({}, definition), { connections: connections.map(convertConnection), actions: convertedActions, triggers: convertedTriggers, dataSources: convertedDataSources });
};
exports.convertComponent = convertComponent;
