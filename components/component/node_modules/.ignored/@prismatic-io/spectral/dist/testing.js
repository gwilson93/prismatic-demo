"use strict";
/**
 * This module provides functions to help developers unit
 * test custom components prior to publishing them. For
 * information on unit testing, check out our docs:
 * https://prismatic.io/docs/custom-components/writing-custom-components/#testing-a-component
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHarness = exports.ComponentTestHarness = exports.invokeFlow = exports.invokeDataSource = exports.invokeTrigger = exports.defaultTriggerPayload = exports.invoke = exports.loggerMock = exports.connectionValue = exports.defaultConnectionValueEnvironmentVariable = exports.createConnection = void 0;
const jest_mock_1 = require("jest-mock");
const createConnection = ({ key }, values, tokenValues) => ({
    configVarKey: "",
    key,
    fields: values,
    token: tokenValues,
});
exports.createConnection = createConnection;
exports.defaultConnectionValueEnvironmentVariable = "PRISMATIC_CONNECTION_VALUE";
const connectionValue = (envVarKey = exports.defaultConnectionValueEnvironmentVariable) => {
    const value = process.env[envVarKey];
    if (!value) {
        throw new Error("Unable to find connection value.");
    }
    const result = Object.assign(Object.assign({}, JSON.parse(value)), { key: "" });
    return result;
};
exports.connectionValue = connectionValue;
/**
 * Pre-built mock of ActionLogger. Suitable for asserting logs are created as expected.
 * See https://prismatic.io/docs/custom-components/writing-custom-components/#verifying-correct-logging-in-action-tests for information on testing correct logging behavior in your custom component.
 */
const loggerMock = () => ({
    metric: console.log,
    trace: (0, jest_mock_1.spyOn)(console, "trace"),
    debug: (0, jest_mock_1.spyOn)(console, "debug"),
    info: (0, jest_mock_1.spyOn)(console, "info"),
    log: (0, jest_mock_1.spyOn)(console, "log"),
    warn: (0, jest_mock_1.spyOn)(console, "warn"),
    error: (0, jest_mock_1.spyOn)(console, "error"),
});
exports.loggerMock = loggerMock;
const createActionContext = (context) => {
    return Object.assign({ logger: (0, exports.loggerMock)(), instanceState: {}, crossFlowState: {}, executionState: {}, integrationState: {}, configVars: {}, stepId: "mockStepId", executionId: "mockExecutionId", webhookUrls: {
            "Flow 1": "https://example.com",
        }, webhookApiKeys: {
            "Flow 1": ["example-123", "example-456"],
        }, invokeUrl: "https://example.com", customer: {
            id: "customerId",
            name: "Customer 1",
            externalId: "1234",
        }, instance: {
            id: "instanceId",
            name: "Instance 1",
        }, user: {
            id: "userId",
            email: "user@example.com",
            name: "User 1",
            externalId: "1234",
        }, integration: {
            id: "integrationId",
            name: "Integration 1",
            versionSequenceId: "1234",
            externalVersion: "1.0.0",
        }, flow: {
            id: "flowId",
            name: "Flow 1",
        }, startedAt: new Date().toISOString() }, context);
};
const createDataSourceContext = (context) => {
    return Object.assign({ logger: (0, exports.loggerMock)(), configVars: {}, customer: {
            id: "customerId",
            name: "Customer 1",
            externalId: "1234",
        }, instance: {
            id: "instanceId",
            name: "Instance 1",
        }, user: {
            id: "userId",
            email: "example@email.com",
            externalId: "1234",
            name: "Example",
        } }, context);
};
/**
 * Invokes specified ActionDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching ActionPerformReturn as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * action result and a mock logger for asserting logging.
 */
const invoke = ({ perform, }, params, context) => __awaiter(void 0, void 0, void 0, function* () {
    const realizedContext = createActionContext(context);
    const result = yield perform(realizedContext, params);
    return {
        result,
        loggerMock: realizedContext.logger,
    };
});
exports.invoke = invoke;
const defaultTriggerPayload = () => {
    const payloadData = { foo: "bar" };
    const contentType = "application/json";
    return {
        headers: {
            "content-type": contentType,
        },
        queryParameters: {},
        rawBody: {
            data: payloadData,
            contentType,
        },
        body: {
            data: JSON.stringify(payloadData),
            contentType,
        },
        pathFragment: "",
        webhookUrls: {
            "Flow 1": "https://example.com",
        },
        webhookApiKeys: {
            "Flow 1": ["example-123", "example-456"],
        },
        invokeUrl: "https://example.com",
        executionId: "executionId",
        customer: {
            id: "customerId",
            name: "Customer 1",
            externalId: "1234",
        },
        instance: {
            id: "instanceId",
            name: "Instance 1",
        },
        user: {
            id: "userId",
            email: "user@example.com",
            name: "User 1",
            externalId: "1234",
        },
        integration: {
            id: "integrationId",
            name: "Integration 1",
            versionSequenceId: "1234",
            externalVersion: "1.0.0",
        },
        flow: {
            id: "flowId",
            name: "Flow 1",
        },
        startedAt: new Date().toISOString(),
    };
};
exports.defaultTriggerPayload = defaultTriggerPayload;
/**
 * Invokes specified TriggerDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching TriggerResult as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * trigger result and a mock logger for asserting logging.
 */
const invokeTrigger = ({ perform, }, context, payload, params) => __awaiter(void 0, void 0, void 0, function* () {
    const realizedContext = createActionContext(context);
    const realizedPayload = Object.assign(Object.assign({}, (0, exports.defaultTriggerPayload)()), payload);
    const realizedParams = params || {};
    const result = yield perform(realizedContext, realizedPayload, realizedParams);
    return {
        result,
        loggerMock: realizedContext.logger,
    };
});
exports.invokeTrigger = invokeTrigger;
/**
 * Invokes specified DataSourceDefinition perform function using supplied params.
 * Accepts a generic type matching DataSourceResult as a convenience to avoid extra
 * casting within test methods. Returns a DataSourceResult.
 */
const invokeDataSource = ({ perform }, params, context) => __awaiter(void 0, void 0, void 0, function* () {
    const realizedContext = createDataSourceContext(context);
    const result = yield perform(realizedContext, params);
    return result;
});
exports.invokeDataSource = invokeDataSource;
const createConfigVars = (values) => {
    return Object.entries(values !== null && values !== void 0 ? values : {}).reduce((result, [key, value]) => {
        // Connection
        if (typeof value === "object" && "fields" in value) {
            return Object.assign(Object.assign({}, result), { [key]: Object.assign(Object.assign({}, value), { key, configVarKey: "" }) });
        }
        return Object.assign(Object.assign({}, result), { [key]: value });
    }, {});
};
/**
 * Invokes specified Flow of a Code Native Integration using supplied params.
 * Runs the Trigger and then the Action function and returns the result of the Action.
 */
const invokeFlow = (flow, { configVars, context, payload, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const realizedConfigVars = createConfigVars(configVars);
    const realizedContext = createActionContext(Object.assign(Object.assign({}, context), { configVars: realizedConfigVars }));
    const realizedPayload = Object.assign(Object.assign({}, (0, exports.defaultTriggerPayload)()), payload);
    const params = {
        onTrigger: { results: realizedPayload },
    };
    if ("onTrigger" in flow && typeof flow.onTrigger === "function") {
        const triggerResult = yield flow.onTrigger(realizedContext, realizedPayload, params);
        params.onTrigger = { results: triggerResult === null || triggerResult === void 0 ? void 0 : triggerResult.payload };
    }
    const result = yield flow.onExecution(realizedContext, params);
    return {
        result,
        loggerMock: realizedContext.logger,
    };
});
exports.invokeFlow = invokeFlow;
class ComponentTestHarness {
    constructor(component) {
        this.component = component;
    }
    buildParams(inputs, params) {
        const defaults = inputs.reduce((result, { key, default: defaultValue }) => (Object.assign(Object.assign({}, result), { [key]: `${defaultValue !== null && defaultValue !== void 0 ? defaultValue : ""}` })), {});
        return Object.assign(Object.assign({}, defaults), params);
    }
    connectionValue({ key }) {
        const { PRISMATIC_CONNECTION_VALUE: value } = process.env;
        if (!value) {
            throw new Error("Unable to find connection value.");
        }
        const result = Object.assign(Object.assign({}, JSON.parse(value)), { key });
        return result;
    }
    trigger(key, payload, params, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const trigger = this.component.triggers[key];
            return trigger.perform(createActionContext(context), Object.assign(Object.assign({}, (0, exports.defaultTriggerPayload)()), payload), this.buildParams(trigger.inputs, params));
        });
    }
    triggerOnInstanceDeploy(key, params, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const trigger = this.component.triggers[key];
            if (!trigger.onInstanceDeploy) {
                throw new Error("Trigger does not support onInstanceDeploy");
            }
            return trigger.onInstanceDeploy(createActionContext(context), this.buildParams(trigger.inputs, params));
        });
    }
    triggerOnInstanceDelete(key, params, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const trigger = this.component.triggers[key];
            if (!trigger.onInstanceDelete) {
                throw new Error("Trigger does not support onInstanceDelete");
            }
            return trigger.onInstanceDelete(createActionContext(context), this.buildParams(trigger.inputs, params));
        });
    }
    action(key, params, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const action = this.component.actions[key];
            return action.perform(createActionContext(context), this.buildParams(action.inputs, params));
        });
    }
    dataSource(key, params, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataSource = this.component.dataSources[key];
            return dataSource.perform(createDataSourceContext(context), this.buildParams(dataSource.inputs, params));
        });
    }
}
exports.ComponentTestHarness = ComponentTestHarness;
const createHarness = (component) => {
    return new ComponentTestHarness(component);
};
exports.createHarness = createHarness;
exports.default = {
    loggerMock: exports.loggerMock,
    invoke: exports.invoke,
    invokeTrigger: exports.invokeTrigger,
    createHarness: exports.createHarness,
    invokeDataSource: exports.invokeDataSource,
};
