"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertIntegration = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
const yaml_1 = __importDefault(require("yaml"));
const uuid_1 = require("uuid");
const lodash_1 = require("lodash");
const types_1 = require("../types");
const convert_1 = require("./convert");
const integration_1 = require("./integration");
const convertIntegration = (definition) => {
    var _a;
    // Generate a unique reference key that will be used to reference the
    // actions, triggers, data sources, and connections that are created
    // inline as part of the integration definition.
    const referenceKey = (0, uuid_1.v4)();
    const configVars = Object.assign({}, ...Object.values((_a = definition.configPages) !== null && _a !== void 0 ? _a : {}).map(({ elements }) => elements));
    return Object.assign(Object.assign({}, codeNativeIntegrationComponent(definition, referenceKey, configVars)), { codeNativeIntegrationYAML: codeNativeIntegrationYaml(definition, referenceKey, configVars) });
};
exports.convertIntegration = convertIntegration;
const convertConfigPages = (pages) => {
    if (!pages || !Object.keys(pages).length) {
        return;
    }
    return Object.entries(pages).map(([name, { tagline, elements }]) => ({
        name,
        tagline,
        elements: Object.keys(elements).map((key) => ({
            type: "configVar",
            value: key,
        })),
    }));
};
const codeNativeIntegrationYaml = ({ name, description, category, documentation, version, labels, endpointType, triggerPreprocessFlowConfig, flows, configPages, }, referenceKey, configVars) => {
    // Find the preprocess flow config on the flow, if one exists.
    const preprocessFlows = flows.filter((flow) => flow.preprocessFlowConfig);
    // Do some validation of preprocess flow configs.
    if (preprocessFlows.length > 1) {
        throw new Error("Only one flow may define a Preprocess Flow Config.");
    }
    if (preprocessFlows.length && triggerPreprocessFlowConfig) {
        throw new Error("Integration must not define both a Trigger Preprocess Flow Config and a Preprocess Flow.");
    }
    const hasPreprocessFlow = preprocessFlows.length > 0;
    const preprocessFlowConfig = hasPreprocessFlow
        ? preprocessFlows[0].preprocessFlowConfig
        : triggerPreprocessFlowConfig;
    const nonPreprocessFlowTypes = [
        "instance_specific",
        "shared_instance",
    ];
    if (nonPreprocessFlowTypes.includes(endpointType || "flow_specific") &&
        !preprocessFlowConfig) {
        throw new Error("Integration with specified EndpointType must define either a Trigger Preprocess Flow Config or a Preprocess Flow.");
    }
    // Transform the IntegrationDefinition into the structure that is appropriate
    // for generating YAML, which will then be used by the Prismatic API to import
    // the integration as a Code Native Integration.
    const result = {
        definitionVersion: integration_1.DefinitionVersion,
        isCodeNative: true,
        name,
        description,
        category,
        documentation,
        version,
        labels,
        requiredConfigVars: Object.entries(configVars || {}).map(([key, configVar]) => convertConfigVar(key, configVar, referenceKey)),
        endpointType,
        preprocessFlowName: hasPreprocessFlow ? preprocessFlows[0].name : undefined,
        externalCustomerIdField: fieldNameToReferenceInput(hasPreprocessFlow ? "onExecution" : "payload", preprocessFlowConfig === null || preprocessFlowConfig === void 0 ? void 0 : preprocessFlowConfig.externalCustomerIdField),
        externalCustomerUserIdField: fieldNameToReferenceInput(hasPreprocessFlow ? "onExecution" : "payload", preprocessFlowConfig === null || preprocessFlowConfig === void 0 ? void 0 : preprocessFlowConfig.externalCustomerUserIdField),
        flowNameField: fieldNameToReferenceInput(hasPreprocessFlow ? "onExecution" : "payload", preprocessFlowConfig === null || preprocessFlowConfig === void 0 ? void 0 : preprocessFlowConfig.flowNameField),
        flows: flows.map((flow) => convertFlow(flow, referenceKey)),
        configPages: convertConfigPages(configPages !== null && configPages !== void 0 ? configPages : {}),
    };
    return yaml_1.default.stringify(result);
};
const convertComponentReference = ({ key, component: componentRef, values, }) => {
    const component = typeof componentRef === "string"
        ? {
            key: componentRef,
            version: "LATEST",
            isPublic: true,
        }
        : {
            key: componentRef.key,
            version: "LATEST",
            isPublic: componentRef.isPublic,
        };
    const inputs = Object.entries(values !== null && values !== void 0 ? values : {}).reduce((result, [key, value]) => {
        if ("value" in value) {
            const type = value.value instanceof Object ? "complex" : "value";
            const valueExpr = value.value instanceof Object && !Array.isArray(value.value)
                ? Object.entries(value.value).map(([k, v]) => ({
                    name: { type: "value", value: k },
                    type: "value",
                    value: v,
                }))
                : value.value;
            return Object.assign(Object.assign({}, result), { [key]: { type: type, value: valueExpr } });
        }
        if ("configVar" in value) {
            return Object.assign(Object.assign({}, result), { [key]: { type: "configVar", value: value.configVar } });
        }
        return result;
    }, {});
    return {
        ref: { key, component },
        inputs,
    };
};
/** Converts a Flow into the structure necessary for YAML generation. */
const convertFlow = (flow, referenceKey) => {
    var _a;
    const result = Object.assign({}, flow);
    delete result.onTrigger;
    delete result.trigger;
    delete result.onInstanceDeploy;
    delete result.onInstanceDelete;
    delete result.onExecution;
    delete result.preprocessFlowConfig;
    delete result.errorConfig;
    const triggerStep = {
        name: "On Trigger",
        stableKey: `${flow.stableKey}-onTrigger`,
        description: "The function that will be executed by the flow to return an HTTP response.",
        isTrigger: true,
        errorConfig: "errorConfig" in flow ? Object.assign({}, flow.errorConfig) : undefined,
    };
    if (typeof flow.onTrigger === "function") {
        triggerStep.action = {
            key: flowFunctionKey(flow.name, "onTrigger"),
            component: {
                key: referenceKey,
                version: "LATEST",
                isPublic: false,
            },
        };
    }
    else if ((0, types_1.isComponentReference)(flow.onTrigger)) {
        const { ref, inputs } = convertComponentReference(flow.onTrigger);
        triggerStep.action = ref;
        triggerStep.inputs = inputs;
    }
    else {
        const hasSchedule = "schedule" in flow && typeof flow.schedule === "object";
        const key = hasSchedule ? "schedule" : "webhook";
        triggerStep.action = {
            key,
            component: { key: `${key}-triggers`, version: "LATEST", isPublic: true },
        };
    }
    if ("schedule" in flow && typeof flow.schedule === "object") {
        const { schedule } = flow;
        triggerStep.schedule = {
            type: "configVar" in schedule ? "configVar" : "value",
            value: "configVar" in schedule ? schedule.configVar : schedule.value,
            meta: {
                scheduleType: "custom",
                timeZone: (_a = schedule.timezone) !== null && _a !== void 0 ? _a : "",
            },
        };
        delete result.schedule;
    }
    const actionStep = {
        action: {
            key: flowFunctionKey(flow.name, "onExecution"),
            component: { key: referenceKey, version: "LATEST", isPublic: false },
        },
        name: "On Execution",
        stableKey: `${flow.stableKey}-onExecution`,
        description: "The function that will be executed by the flow.",
        errorConfig: "errorConfig" in flow ? Object.assign({}, flow.errorConfig) : undefined,
    };
    result.steps = [triggerStep, actionStep];
    return result;
};
/** Converts a Config Var into the structure necessary for YAML generation. */
const convertConfigVar = (key, configVar, referenceKey) => {
    const meta = (0, lodash_1.pick)(configVar, [
        "visibleToCustomerDeployer",
        "visibleToOrgDeployer",
    ]);
    if ((0, types_1.isConnectionDefinitionConfigVar)(configVar)) {
        return Object.assign(Object.assign({}, (0, lodash_1.pick)(configVar, ["stableKey", "description", "orgOnly"])), { key, dataType: "connection", connection: {
                component: { key: referenceKey, version: "LATEST", isPublic: false },
                key: (0, lodash_1.camelCase)(key),
            }, inputs: Object.entries(configVar.inputs).reduce((result, [key, input]) => {
                if (input.shown === false) {
                    return result;
                }
                const defaultValue = input.collection ? [] : "";
                return Object.assign(Object.assign({}, result), { [key]: {
                        type: input.collection ? "complex" : "value",
                        value: input.default || defaultValue,
                    } });
            }, {}), meta });
    }
    if ((0, types_1.isConnectionReferenceConfigVar)(configVar)) {
        const { ref, inputs } = convertComponentReference(configVar.connection);
        return Object.assign(Object.assign({}, (0, lodash_1.pick)(configVar, ["stableKey", "description", "orgOnly"])), { key, dataType: "connection", connection: Object.assign(Object.assign({}, ref), { template: configVar.connection.template }), inputs });
    }
    const result = (0, lodash_1.assign)({ meta, key }, (0, lodash_1.pick)(configVar, [
        "stableKey",
        "description",
        "orgOnly",
        "defaultValue",
        "dataType",
        "pickList",
        "timeZone",
        "codeLanguage",
        "collectionType",
    ]));
    if ((0, types_1.isScheduleConfigVar)(configVar)) {
        result.scheduleType = "custom";
    }
    if ((0, types_1.isDataSourceDefinitionConfigVar)(configVar)) {
        result.dataType = configVar.dataSourceType;
        result.dataSource = {
            key: (0, lodash_1.camelCase)(key),
            component: { key: referenceKey, version: "LATEST", isPublic: false },
        };
    }
    if ((0, types_1.isDataSourceReferenceConfigVar)(configVar)) {
        const { ref, inputs } = convertComponentReference(configVar.dataSource);
        result.dataType = configVar.dataSourceType;
        result.dataSource = ref;
        result.inputs = inputs;
    }
    return result;
};
/** Maps the step name field to a fully qualified input. */
const fieldNameToReferenceInput = (stepName, fieldName) => fieldName
    ? { type: "reference", value: `${stepName}.results.${fieldName}` }
    : undefined;
/** Actions and Triggers will be scoped to their flow by combining the flow
 *  name and the function name. This is to ensure that the keys are unique
 *  on the resulting object, which will be turned into a Component. */
const flowFunctionKey = (flowName, functionName) => {
    const flowKey = flowName
        .replace(/[^0-9a-zA-Z]+/g, " ")
        .trim()
        .split(" ")
        .map((w, i) => i === 0
        ? w.toLowerCase()
        : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join("");
    return `${flowKey}_${functionName}`;
};
/** Creates the structure necessary to import a Component as part of a
 *  Code Native integration. */
const codeNativeIntegrationComponent = ({ name, iconPath, description, flows = [], }, referenceKey, configVars) => {
    const convertedActions = flows.reduce((result, { name, onExecution }) => {
        const key = flowFunctionKey(name, "onExecution");
        return Object.assign(Object.assign({}, result), { [key]: {
                key,
                display: {
                    label: `${name} - onExecution`,
                    description: "The function that will be executed by the flow.",
                },
                perform: onExecution,
                inputs: [],
            } });
    }, {});
    const convertedTriggers = flows.reduce((result, { name, onTrigger, onInstanceDeploy, onInstanceDelete }) => {
        if (typeof onTrigger !== "function") {
            return result;
        }
        const key = flowFunctionKey(name, "onTrigger");
        return Object.assign(Object.assign({}, result), { [key]: {
                key,
                display: {
                    label: `${name} - onTrigger`,
                    description: "The function that will be executed by the flow to return an HTTP response.",
                },
                perform: onTrigger,
                onInstanceDeploy,
                hasOnInstanceDeploy: !!onInstanceDeploy,
                onInstanceDelete,
                hasOnInstanceDelete: !!onInstanceDelete,
                inputs: [],
                scheduleSupport: "valid",
                synchronousResponseSupport: "valid",
            } });
    }, {});
    const convertedDataSources = Object.entries(configVars).reduce((result, [key, configVar]) => {
        if (!(0, types_1.isDataSourceDefinitionConfigVar)(configVar)) {
            return result;
        }
        const camelKey = (0, lodash_1.camelCase)(key);
        const dataSource = (0, lodash_1.pick)(configVar, ["perform", "dataSourceType"]);
        return Object.assign(Object.assign({}, result), { [camelKey]: Object.assign(Object.assign({}, dataSource), { key: camelKey, display: {
                    label: key,
                    description: key,
                }, inputs: [] }) });
    }, {});
    const convertedConnections = Object.entries(configVars).reduce((result, [key, configVar]) => {
        if (!(0, types_1.isConnectionDefinitionConfigVar)(configVar)) {
            return result;
        }
        const convertedInputs = Object.entries(configVar.inputs).map(([key, value]) => (0, convert_1.convertInput)(key, value));
        const connection = (0, lodash_1.pick)(configVar, ["oauth2Type", "iconPath"]);
        return [
            ...result,
            Object.assign(Object.assign({}, connection), { inputs: convertedInputs, key: (0, lodash_1.camelCase)(key), label: key }),
        ];
    }, []);
    return {
        key: referenceKey,
        display: {
            label: referenceKey,
            iconPath,
            description: description || name,
        },
        connections: convertedConnections,
        actions: convertedActions,
        triggers: convertedTriggers,
        dataSources: convertedDataSources,
    };
};
