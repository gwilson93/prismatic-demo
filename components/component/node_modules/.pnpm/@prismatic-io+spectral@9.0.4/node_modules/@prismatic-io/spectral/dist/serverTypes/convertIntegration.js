"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertIntegration = void 0;
const yaml_1 = __importDefault(require("yaml"));
const uuid_1 = require("uuid");
const lodash_1 = require("lodash");
const types_1 = require("../types");
const convertComponent_1 = require("./convertComponent");
const integration_1 = require("./integration");
const convertIntegration = (definition) => {
    var _a, _b;
    // Generate a unique reference key that will be used to reference the
    // actions, triggers, data sources, and connections that are created
    // inline as part of the integration definition.
    const referenceKey = (0, uuid_1.v4)();
    const configVars = Object.values({
        configPages: (_a = definition.configPages) !== null && _a !== void 0 ? _a : {},
        userLevelConfigPages: (_b = definition.userLevelConfigPages) !== null && _b !== void 0 ? _b : {},
    }).reduce((acc, configPages) => (Object.assign(Object.assign({}, acc), Object.values(configPages).reduce((acc, configPage) => Object.entries(configPage.elements).reduce((acc, [key, element]) => {
        // "string" elements are HTML elements and should be ignored.
        if (typeof element === "string") {
            return acc;
        }
        if (key in acc) {
            throw new Error(`Duplicate config var key: "${key}"`);
        }
        return Object.assign(Object.assign({}, acc), { [key]: element });
    }, acc), {}))), {});
    const cniComponent = codeNativeIntegrationComponent(definition, referenceKey, configVars);
    const cniYaml = codeNativeIntegrationYaml(definition, referenceKey, configVars);
    return Object.assign(Object.assign({}, cniComponent), { codeNativeIntegrationYAML: cniYaml });
};
exports.convertIntegration = convertIntegration;
const convertConfigPages = (pages, userLevelConfigured) => {
    if (!pages || !Object.keys(pages).length) {
        return [];
    }
    return Object.entries(pages).map(([name, { tagline, elements }]) => (Object.assign(Object.assign({ name,
        tagline }, (userLevelConfigured ? { userLevelConfigured } : {})), { elements: Object.entries(elements).map(([key, value]) => typeof value === "string"
            ? {
                type: "htmlElement",
                value,
            }
            : {
                type: "configVar",
                value: key,
            }) })));
};
const codeNativeIntegrationYaml = ({ name, description, category, documentation, version, labels, endpointType, triggerPreprocessFlowConfig, flows, configPages, userLevelConfigPages, componentRegistry = {}, }, referenceKey, configVars) => {
    // Find the preprocess flow config on the flow, if one exists.
    const preprocessFlows = flows.filter((flow) => flow.preprocessFlowConfig);
    // Do some validation of preprocess flow configs.
    if (preprocessFlows.length > 1) {
        throw new Error("Only one flow may define a Preprocess Flow Config.");
    }
    if (preprocessFlows.length && triggerPreprocessFlowConfig) {
        throw new Error("Integration must not define both a Trigger Preprocess Flow Config and a Preprocess Flow.");
    }
    const hasPreprocessFlow = preprocessFlows.length > 0;
    const preprocessFlowConfig = hasPreprocessFlow
        ? preprocessFlows[0].preprocessFlowConfig
        : triggerPreprocessFlowConfig;
    const nonPreprocessFlowTypes = ["instance_specific", "shared_instance"];
    if (nonPreprocessFlowTypes.includes(endpointType || "flow_specific") && !preprocessFlowConfig) {
        throw new Error("Integration with specified EndpointType must define either a Trigger Preprocess Flow Config or a Preprocess Flow.");
    }
    // Transform the IntegrationDefinition into the structure that is appropriate
    // for generating YAML, which will then be used by the Prismatic API to import
    // the integration as a Code Native Integration.
    const result = {
        definitionVersion: integration_1.DefinitionVersion,
        isCodeNative: true,
        name,
        description,
        category,
        documentation,
        version,
        labels,
        requiredConfigVars: Object.entries(configVars || {}).map(([key, configVar]) => convertConfigVar(key, configVar, referenceKey, componentRegistry)),
        endpointType,
        preprocessFlowName: hasPreprocessFlow ? preprocessFlows[0].name : undefined,
        externalCustomerIdField: fieldNameToReferenceInput(hasPreprocessFlow ? "onExecution" : "payload", preprocessFlowConfig === null || preprocessFlowConfig === void 0 ? void 0 : preprocessFlowConfig.externalCustomerIdField),
        externalCustomerUserIdField: fieldNameToReferenceInput(hasPreprocessFlow ? "onExecution" : "payload", preprocessFlowConfig === null || preprocessFlowConfig === void 0 ? void 0 : preprocessFlowConfig.externalCustomerUserIdField),
        flowNameField: fieldNameToReferenceInput(hasPreprocessFlow ? "onExecution" : "payload", preprocessFlowConfig === null || preprocessFlowConfig === void 0 ? void 0 : preprocessFlowConfig.flowNameField),
        flows: flows.map((flow) => convertFlow(flow, componentRegistry, referenceKey)),
        configPages: [
            ...convertConfigPages(configPages, false),
            ...convertConfigPages(userLevelConfigPages, true),
        ],
    };
    return yaml_1.default.stringify(result);
};
const permissionAndVisibilityTypeValueMap = {
    customer: {
        orgOnly: false,
        visibleToOrgDeployer: true,
        visibleToCustomerDeployer: true,
    },
    embedded: {
        orgOnly: false,
        visibleToOrgDeployer: true,
        visibleToCustomerDeployer: false,
    },
    organization: {
        orgOnly: true,
        visibleToOrgDeployer: true,
        visibleToCustomerDeployer: false,
    },
};
const getPermissionAndVisibilityValues = ({ permissionAndVisibilityType = "customer", visibleToOrgDeployer = true, }) => {
    return Object.assign(Object.assign({}, permissionAndVisibilityTypeValueMap[permissionAndVisibilityType]), (visibleToOrgDeployer !== undefined ? { visibleToOrgDeployer } : {}));
};
/** Converts permission and visibility properties into `meta` properties for inputs. */
const convertInputPermissionAndVisibility = ({ permissionAndVisibilityType, visibleToOrgDeployer, }) => {
    const meta = getPermissionAndVisibilityValues({
        permissionAndVisibilityType,
        visibleToOrgDeployer,
    });
    return meta;
};
/** Converts permission and visibility properties into `meta` properties for config vars. */
const convertConfigVarPermissionAndVisibility = ({ permissionAndVisibilityType, visibleToOrgDeployer: visibleToOrgDeployerBase, }) => {
    const { orgOnly, visibleToCustomerDeployer, visibleToOrgDeployer } = getPermissionAndVisibilityValues({
        permissionAndVisibilityType,
        visibleToOrgDeployer: visibleToOrgDeployerBase,
    });
    return {
        orgOnly,
        meta: {
            visibleToCustomerDeployer,
            visibleToOrgDeployer,
        },
    };
};
const convertComponentReference = (componentReference, componentRegistry, referenceType) => {
    var _a, _b;
    const manifest = componentRegistry[componentReference.component];
    if (!manifest) {
        throw new Error(`Component with key "${componentReference.component}" not found in component registry.`);
    }
    const ref = {
        component: {
            key: manifest.key,
            signature: (_a = manifest.signature) !== null && _a !== void 0 ? _a : "",
            isPublic: manifest.public,
        },
        key: componentReference.key,
    };
    const manifestEntry = manifest[referenceType][componentReference.key];
    const inputs = Object.entries((_b = componentReference.values) !== null && _b !== void 0 ? _b : {}).reduce((result, [key, value]) => {
        const manifestEntryInput = manifestEntry.inputs[key];
        const type = manifestEntryInput.collection
            ? "complex"
            : "value" in value
                ? "value"
                : "configVar";
        if ("value" in value) {
            const valueExpr = manifestEntryInput.collection === "keyvaluelist" && value.value instanceof Object
                ? Object.entries(value.value).map(([k, v]) => ({
                    name: { type: "value", value: k },
                    type: "value",
                    value: v,
                }))
                : value.value;
            const formattedValue = type === "complex" || typeof valueExpr === "string" ? valueExpr : JSON.stringify(valueExpr);
            const meta = convertInputPermissionAndVisibility((0, lodash_1.pick)(value, ["permissionAndVisibilityType", "visibleToOrgDeployer"]));
            return Object.assign(Object.assign({}, result), { [key]: { type: type, value: formattedValue, meta } });
        }
        if ("configVar" in value) {
            return Object.assign(Object.assign({}, result), { [key]: { type: "configVar", value: value.configVar } });
        }
        return result;
    }, {});
    return {
        ref,
        inputs,
    };
};
const convertComponentRegistry = (componentRegistry) => Object.values(componentRegistry).map(({ key, public: isPublic, signature }) => ({
    key,
    signature: signature !== null && signature !== void 0 ? signature : "",
    isPublic,
}));
/**
 * Create a reference to the private component built as part of this CNI.
 *
 * References to this component always use `version: "LATEST", isPublic: false`
 * because they automatically publish alongside the corresponding CNI yml.
 * */
const codeNativeIntegrationComponentReference = (referenceKey) => ({
    key: referenceKey,
    version: "LATEST",
    isPublic: false,
});
/** Converts a Flow into the structure necessary for YAML generation. */
const convertFlow = (flow, componentRegistry, referenceKey) => {
    var _a;
    const result = Object.assign({}, flow);
    result.onTrigger = undefined;
    result.trigger = undefined;
    result.onInstanceDeploy = undefined;
    result.onInstanceDelete = undefined;
    result.onExecution = undefined;
    result.preprocessFlowConfig = undefined;
    result.errorConfig = undefined;
    const triggerStep = {
        name: "On Trigger",
        stableKey: `${flow.stableKey}-onTrigger`,
        description: "The function that will be executed by the flow to return an HTTP response.",
        isTrigger: true,
        errorConfig: "errorConfig" in flow ? Object.assign({}, flow.errorConfig) : undefined,
    };
    if (typeof flow.onTrigger === "function") {
        triggerStep.action = {
            key: flowFunctionKey(flow.name, "onTrigger"),
            component: codeNativeIntegrationComponentReference(referenceKey),
        };
    }
    else if ((0, types_1.isComponentReference)(flow.onTrigger)) {
        const { ref, inputs } = convertComponentReference(flow.onTrigger, componentRegistry, "triggers");
        triggerStep.action = ref;
        triggerStep.inputs = inputs;
    }
    else {
        const hasSchedule = "schedule" in flow && typeof flow.schedule === "object";
        const key = hasSchedule ? "schedule" : "webhook";
        triggerStep.action = {
            key,
            component: {
                key: `${key}-triggers`,
                /**
                 * TODO: Add support for specific versions of platform triggers
                 */
                version: "LATEST",
                isPublic: true,
            },
        };
    }
    if ("schedule" in flow && typeof flow.schedule === "object") {
        const { schedule } = flow;
        triggerStep.schedule = {
            type: "configVar" in schedule ? "configVar" : "value",
            value: "configVar" in schedule ? schedule.configVar : schedule.value,
            meta: {
                scheduleType: "custom",
                timeZone: (_a = schedule.timezone) !== null && _a !== void 0 ? _a : "",
            },
        };
        result.schedule = undefined;
    }
    const actionStep = {
        action: {
            key: flowFunctionKey(flow.name, "onExecution"),
            component: codeNativeIntegrationComponentReference(referenceKey),
        },
        name: "On Execution",
        stableKey: `${flow.stableKey}-onExecution`,
        description: "The function that will be executed by the flow.",
        errorConfig: "errorConfig" in flow ? Object.assign({}, flow.errorConfig) : undefined,
    };
    result.steps = [triggerStep, actionStep];
    result.supplementalComponents = convertComponentRegistry(componentRegistry);
    return result;
};
/** Converts an input value to the expected server type by its collection type */
const convertInputValue = (value, collectionType) => {
    if (collectionType !== "keyvaluelist") {
        return value;
    }
    if (Array.isArray(value)) {
        return value;
    }
    return Object.entries(value).map(([key, value]) => ({
        key,
        value: typeof value === "string" ? value : JSON.stringify(value),
    }));
};
/** Converts a Config Var into the structure necessary for YAML generation. */
const convertConfigVar = (key, configVar, referenceKey, componentRegistry) => {
    const { orgOnly, meta } = convertConfigVarPermissionAndVisibility((0, lodash_1.pick)(configVar, ["permissionAndVisibilityType", "visibleToOrgDeployer"]));
    if ((0, types_1.isConnectionDefinitionConfigVar)(configVar)) {
        const { stableKey, description } = (0, lodash_1.pick)(configVar, ["stableKey", "description"]);
        return {
            stableKey,
            description,
            key,
            dataType: "connection",
            connection: {
                key: (0, lodash_1.camelCase)(key),
                component: codeNativeIntegrationComponentReference(referenceKey),
            },
            inputs: Object.entries(configVar.inputs).reduce((result, [key, input]) => {
                if (input.shown === false) {
                    return result;
                }
                const defaultValue = input.collection ? [] : "";
                return Object.assign(Object.assign({}, result), { [key]: {
                        type: input.collection ? "complex" : "value",
                        value: input.default || defaultValue,
                    } });
            }, {}),
            orgOnly,
            meta,
        };
    }
    if ((0, types_1.isConnectionReferenceConfigVar)(configVar)) {
        const { ref, inputs } = convertComponentReference(configVar.connection, componentRegistry, "connections");
        const { stableKey = "", description, connection: { template, onPremiseConnectionConfig }, } = (0, lodash_1.pick)(configVar, ["stableKey", "description", "connection"]);
        return {
            stableKey,
            description,
            key,
            dataType: "connection",
            onPremiseConnectionConfig,
            connection: Object.assign(Object.assign({}, ref), { template }),
            inputs,
            orgOnly,
            meta,
        };
    }
    const rawDefaultValue = "defaultValue" in configVar
        ? convertInputValue(configVar.defaultValue, configVar.collectionType)
        : undefined;
    const defaultValue = typeof rawDefaultValue !== "undefined"
        ? typeof rawDefaultValue === "string"
            ? rawDefaultValue
            : JSON.stringify(rawDefaultValue)
        : undefined;
    const result = (0, lodash_1.assign)({ orgOnly, meta, key, defaultValue }, (0, lodash_1.pick)(configVar, [
        "stableKey",
        "description",
        "dataType",
        "pickList",
        "timeZone",
        "codeLanguage",
        "collectionType",
    ]));
    if ((0, types_1.isScheduleConfigVar)(configVar)) {
        result.scheduleType = "custom";
    }
    if ((0, types_1.isDataSourceDefinitionConfigVar)(configVar)) {
        result.dataType = configVar.dataSourceType;
        result.dataSource = {
            key: (0, lodash_1.camelCase)(key),
            component: codeNativeIntegrationComponentReference(referenceKey),
        };
    }
    if ((0, types_1.isDataSourceReferenceConfigVar)(configVar)) {
        const { ref, inputs } = convertComponentReference(configVar.dataSource, componentRegistry, "dataSources");
        result.dataType = componentRegistry[ref.component.key].dataSources[ref.key].dataSourceType;
        result.dataSource = ref;
        result.inputs = inputs;
    }
    return result;
};
/** Maps the step name field to a fully qualified input. */
const fieldNameToReferenceInput = (stepName, fieldName) => fieldName ? { type: "reference", value: `${stepName}.results.${fieldName}` } : undefined;
/** Actions and Triggers will be scoped to their flow by combining the flow
 *  name and the function name. This is to ensure that the keys are unique
 *  on the resulting object, which will be turned into a Component. */
const flowFunctionKey = (flowName, functionName) => {
    const flowKey = flowName
        .replace(/[^0-9a-zA-Z]+/g, " ")
        .trim()
        .split(" ")
        .map((w, i) => i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
        .join("");
    return `${flowKey}_${functionName}`;
};
const convertOnExecution = (onExecution, componentRegistry) => (context, params) => {
    const { 
    // @ts-expect-error _components isn't part of the public API
    _components } = context, remainingContext = __rest(context, ["_components"]);
    const invoke = _components.invoke;
    // Construct the component methods from the component registry
    const componentMethods = Object.entries(componentRegistry).reduce((accumulator, [registryComponentKey, { key: componentKey, actions, public: isPublic, signature }]) => {
        const componentActions = Object.entries(actions).reduce((actionsAccumulator, [actionKey, action]) => {
            // Define the method to be called for the action
            const invokeAction = (values) => __awaiter(void 0, void 0, void 0, function* () {
                // Transform the input values based on the action's inputs
                const transformedValues = Object.entries(values).reduce((transformedAccumulator, [inputKey, inputValue]) => {
                    const { collection } = action.inputs[inputKey];
                    return Object.assign(Object.assign({}, transformedAccumulator), { [inputKey]: convertInputValue(inputValue, collection) });
                }, {});
                // Invoke the action with the transformed values
                return invoke({
                    component: {
                        key: componentKey,
                        signature: signature !== null && signature !== void 0 ? signature : "",
                        isPublic,
                    },
                    key: actionKey,
                }, context, transformedValues);
            });
            return Object.assign(Object.assign({}, actionsAccumulator), { [actionKey]: invokeAction });
        }, {});
        return Object.assign(Object.assign({}, accumulator), { [registryComponentKey]: componentActions });
    }, {});
    return onExecution(Object.assign(Object.assign({}, remainingContext), { components: componentMethods }), params);
};
/** Creates the structure necessary to import a Component as part of a
 *  Code Native integration. */
const codeNativeIntegrationComponent = ({ name, iconPath, description, flows = [], componentRegistry = {} }, referenceKey, configVars) => {
    const convertedActions = flows.reduce((result, { name, onExecution }) => {
        const key = flowFunctionKey(name, "onExecution");
        return Object.assign(Object.assign({}, result), { [key]: {
                key,
                display: {
                    label: `${name} - onExecution`,
                    description: "The function that will be executed by the flow.",
                },
                perform: convertOnExecution(onExecution, componentRegistry),
                inputs: [],
            } });
    }, {});
    const convertedTriggers = flows.reduce((result, { name, onTrigger, onInstanceDeploy, onInstanceDelete }) => {
        if (typeof onTrigger !== "function") {
            return result;
        }
        const key = flowFunctionKey(name, "onTrigger");
        return Object.assign(Object.assign({}, result), { [key]: {
                key,
                display: {
                    label: `${name} - onTrigger`,
                    description: "The function that will be executed by the flow to return an HTTP response.",
                },
                perform: onTrigger,
                onInstanceDeploy: onInstanceDeploy,
                hasOnInstanceDeploy: !!onInstanceDeploy,
                onInstanceDelete: onInstanceDelete,
                hasOnInstanceDelete: !!onInstanceDelete,
                inputs: [],
                scheduleSupport: "valid",
                synchronousResponseSupport: "valid",
            } });
    }, {});
    const convertedDataSources = Object.entries(configVars).reduce((result, [key, configVar]) => {
        if (!(0, types_1.isDataSourceDefinitionConfigVar)(configVar)) {
            return result;
        }
        const camelKey = (0, lodash_1.camelCase)(key);
        const dataSource = (0, lodash_1.pick)(configVar, ["perform", "dataSourceType"]);
        return Object.assign(Object.assign({}, result), { [camelKey]: Object.assign(Object.assign({}, dataSource), { key: camelKey, display: {
                    label: key,
                    description: key,
                }, inputs: [] }) });
    }, {});
    const convertedConnections = Object.entries(configVars).reduce((result, [key, configVar]) => {
        if (!(0, types_1.isConnectionDefinitionConfigVar)(configVar)) {
            return result;
        }
        const convertedInputs = Object.entries(configVar.inputs).map(([key, value]) => (0, convertComponent_1.convertInput)(key, value));
        const connection = (0, lodash_1.pick)(configVar, ["oauth2Type", "iconPath"]);
        return [
            ...result,
            Object.assign(Object.assign({}, connection), { inputs: convertedInputs, key: (0, lodash_1.camelCase)(key), label: key }),
        ];
    }, []);
    return {
        key: referenceKey,
        display: {
            label: referenceKey,
            iconPath,
            description: description || name,
        },
        connections: convertedConnections,
        actions: convertedActions,
        triggers: convertedTriggers,
        dataSources: convertedDataSources,
    };
};
