/**
 * This module provides functions to help developers unit
 * test custom components prior to publishing them. For
 * information on unit testing, check out our docs:
 * https://prismatic.io/docs/custom-components/writing-custom-components/#testing-a-component
 */
import { TriggerPayload, TriggerResult, ConnectionValue, ActionLogger, Component, ActionContext, ActionPerformReturn, DataSourceResult, DataSourceContext } from "./serverTypes";
import { ConnectionDefinition, ActionDefinition, TriggerDefinition, Inputs, ActionInputParameters, DataSourceDefinition, ActionPerformReturn as InvokeActionPerformReturn, TriggerResult as InvokeTriggerResult, DataSourceType, DataSourceResult as InvokeDataSourceResult, TriggerEventFunctionReturn, Flow, ConfigVarResultCollection } from "./types";
export declare const createConnection: <T extends ConnectionDefinition>({ key }: T, values: Record<string, unknown>, tokenValues?: Record<string, unknown>) => ConnectionValue;
export declare const defaultConnectionValueEnvironmentVariable = "PRISMATIC_CONNECTION_VALUE";
export declare const connectionValue: (envVarKey?: string) => ConnectionValue;
/**
 * Pre-built mock of ActionLogger. Suitable for asserting logs are created as expected.
 * See https://prismatic.io/docs/custom-components/writing-custom-components/#verifying-correct-logging-in-action-tests for information on testing correct logging behavior in your custom component.
 */
export declare const loggerMock: () => ActionLogger;
/**
 * The type of data returned by an `invoke()` function used for unit testing component actions and triggers.
 */
interface InvokeReturn<ReturnData> {
    result: ReturnData;
    loggerMock: ActionLogger;
}
/**
 * Invokes specified ActionDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching ActionPerformReturn as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * action result and a mock logger for asserting logging.
 */
export declare const invoke: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TReturn extends InvokeActionPerformReturn<TAllowsBranching, unknown>>({ perform }: ActionDefinition<TInputs, TConfigVars, TAllowsBranching, TReturn>, params: ActionInputParameters<TInputs>, context?: Partial<ActionContext<TConfigVars>>) => Promise<InvokeReturn<TReturn>>;
export declare const defaultTriggerPayload: () => TriggerPayload;
/**
 * Invokes specified TriggerDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching TriggerResult as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * trigger result and a mock logger for asserting logging.
 */
export declare const invokeTrigger: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TResult extends InvokeTriggerResult<TAllowsBranching, TriggerPayload>>({ perform }: TriggerDefinition<TInputs, TConfigVars, TAllowsBranching, TResult>, context?: Partial<ActionContext<TConfigVars>>, payload?: TriggerPayload, params?: ActionInputParameters<TInputs>) => Promise<InvokeReturn<TResult>>;
/**
 * Invokes specified DataSourceDefinition perform function using supplied params.
 * Accepts a generic type matching DataSourceResult as a convenience to avoid extra
 * casting within test methods. Returns a DataSourceResult.
 */
export declare const invokeDataSource: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TDataSourceType extends DataSourceType>({ perform }: DataSourceDefinition<TInputs, TConfigVars, TDataSourceType>, params: ActionInputParameters<TInputs>, context?: Partial<DataSourceContext<TConfigVars>>) => Promise<InvokeDataSourceResult<TDataSourceType>>;
type TestConnectionValue = Pick<ConnectionValue, "fields" | "context" | "token">;
type TestConfigVarValues = Record<string, string | TestConnectionValue>;
type ToTestValues<TConfigVars extends ConfigVarResultCollection> = {
    [K in keyof TConfigVars]: TConfigVars[K] extends ConnectionDefinition ? TestConnectionValue : string;
};
/**
 * Invokes specified Flow of a Code Native Integration using supplied params.
 * Runs the Trigger and then the Action function and returns the result of the Action.
 */
export declare const invokeFlow: <TConfigVars extends ConfigVarResultCollection = ConfigVarResultCollection, TConfigVarValues extends TestConfigVarValues = ToTestValues<TConfigVars>>(flow: Flow, { configVars, context, payload, }?: {
    configVars?: TConfigVarValues;
    context?: Partial<ActionContext<TConfigVars>>;
    payload?: Partial<TriggerPayload>;
}) => Promise<InvokeReturn<InvokeActionPerformReturn<false, unknown>>>;
export declare class ComponentTestHarness<TComponent extends Component> {
    component: TComponent;
    constructor(component: TComponent);
    private buildParams;
    connectionValue({ key }: ConnectionDefinition): ConnectionValue;
    trigger<TConfigVars extends ConfigVarResultCollection>(key: string, payload?: TriggerPayload, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerResult>;
    triggerOnInstanceDeploy<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerEventFunctionReturn | void>;
    triggerOnInstanceDelete<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerEventFunctionReturn | void>;
    action<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<ActionPerformReturn>;
    dataSource<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<DataSourceContext<TConfigVars>>): Promise<DataSourceResult>;
}
export declare const createHarness: <TComponent extends Component>(component: TComponent) => ComponentTestHarness<TComponent>;
declare const _default: {
    loggerMock: () => ActionLogger;
    invoke: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TReturn extends InvokeActionPerformReturn<TAllowsBranching, unknown>>({ perform }: ActionDefinition<TInputs, TConfigVars, TAllowsBranching, TReturn>, params: ActionInputParameters<TInputs>, context?: Partial<ActionContext<TConfigVars>>) => Promise<InvokeReturn<TReturn>>;
    invokeTrigger: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TResult extends InvokeTriggerResult<TAllowsBranching, TriggerPayload>>({ perform }: TriggerDefinition<TInputs, TConfigVars, TAllowsBranching, TResult>, context?: Partial<ActionContext<TConfigVars>>, payload?: TriggerPayload, params?: ActionInputParameters<TInputs>) => Promise<InvokeReturn<TResult>>;
    createHarness: <TComponent extends Component>(component: TComponent) => ComponentTestHarness<TComponent>;
    invokeDataSource: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TDataSourceType extends DataSourceType>({ perform }: DataSourceDefinition<TInputs, TConfigVars, TDataSourceType>, params: ActionInputParameters<TInputs>, context?: Partial<DataSourceContext<TConfigVars>>) => Promise<InvokeDataSourceResult<TDataSourceType>>;
};
export default _default;
